<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

    <title>Week3 Assignment</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/styles.css">
    <link href='https://fonts.googleapis.com/css?family=Oxygen:400,300,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Lora' rel='stylesheet' type='text/css'>
  </head>
<body>

    <!--
    <h1>Intel x86 Architecture Design</h1> 
    -->
    <header>
      <nav id="header-nav" class="navbar navbar-default">
        <div class="container">

          <div class="navbar-header">
            <div class="navbar-brand">
              <h1>Intel x86 Architecture</h1>
            </div>
        
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapsable-nav" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
          </div>  <!-- class="navbar-header" -->

          <div id="collapsable-nav" class="collapse navbar-collapse">
            <ul id="nav-list" class="nav navbar-nav navbar-right">
              <li class="visible-xs active">
                <span>Superscalar Pipelining</span>
              </li>
              <li class="visible-xs active">
                <span>Branch Prediction</span>
              </li>
              <li class="visible-xs active">
                <span>Out-of-Order Execution</span>
              </li>
            </ul>         
          </div> <!-- id="collapsable-nav" class="collapse navbar-collapse"  -->

        </div> <!-- class="container" -->
      </nav>
    </header>

    <div id="sec-title" class="container">
        <h2>Sections</h2>
    </div>

    <div id="main-content" class="container">


      <div class="col-md-12 col-sm-12 col-xs-12">
        <p class="subtitle">Superscalar Pipelining</p>
        <p>Three instructions ( superscalar ) are being fetched at each clock cycle. A typical modern Intel processor contains around 33 pipeline stages. The key idea of pipelining is to be able to spit out one execution result per clock cycle compared to the primitive single stage designs that would otherwise consumes at least five cycles to achieve one instruction. Pipelining largely increases processor speed compared to simply cranking up frequencies.Three instructions ( superscalar ) are being fetched at each clock cycle. A typical modern Intel processor contains around 33 pipeline stages. The key idea of pipelining is to be able to spit out one execution result per clock cycle compared to the primitive single stage designs that would otherwise consumes at least five cycles to achieve one instruction. Pipelining largely increases processor speed compared to simply cranking up frequencies.Three instructions ( superscalar ) are being fetched at each clock cycle. A typical modern Intel processor contains around 33 pipeline stages. The key idea of pipelining is to be able to spit out one execution result per clock cycle compared to the primitive single stage designs that would otherwise consumes at least five cycles to achieve one instruction. Pipelining largely increases processor speed compared to simply cranking up frequencies.Three instructions ( superscalar ) are being fetched at each clock cycle. A typical modern Intel processor contains around 33 pipeline stages. The key idea of pipelining is to be able to spit out one execution result per clock cycle compared to the primitive single stage designs that would otherwise consumes at least five cycles to achieve one instruction. Pipelining largely increases processor speed compared to simply cranking up frequencies.Three instructions ( superscalar ) are being fetched at each clock cycle. A typical modern Intel processor contains around 33 pipeline stages. The key idea of pipelining is to be able to spit out one execution result per clock cycle compared to the primitive single stage designs that would otherwise consumes at least five cycles to achieve one instruction. Pipelining largely increases processor speed compared to simply cranking up frequencies.Three instructions ( superscalar ) are being fetched at each clock cycle. A typical modern Intel processor contains around 33 pipeline stages. The key idea of pipelining is to be able to spit out one execution result per clock cycle compared to the primitive single stage designs that would otherwise consumes at least five cycles to achieve one instruction. Pipelining largely increases processor speed compared to simply cranking up frequencies.</p>
      </div>
    
      <div class="col-md-12 col-sm-12 col-xs-12">
        <p class="subtitle">Branch Prediction</p>
        <p>Many times when the next ( a few ) instructions depend on the result of previous instructions ( e.g., if conditions ), a prediction must be made. In general, floating number problems are easier to predict but integer comparisons are more difficult to anticipate. If the branch is predicted wrong, the whole pipeline must be flushed out and restart by fetching the correct branch.Many times when the next ( a few ) instructions depend on the result of previous instructions ( e.g., if conditions ), a prediction must be made. In general, floating number problems are easier to predict but integer comparisons are more difficult to anticipate. If the branch is predicted wrong, the whole pipeline must be flushed out and restart by fetching the correct branch.Many times when the next ( a few ) instructions depend on the result of previous instructions ( e.g., if conditions ), a prediction must be made. In general, floating number problems are easier to predict but integer comparisons are more difficult to anticipate. If the branch is predicted wrong, the whole pipeline must be flushed out and restart by fetching the correct branch.Many times when the next ( a few ) instructions depend on the result of previous instructions ( e.g., if conditions ), a prediction must be made. In general, floating number problems are easier to predict but integer comparisons are more difficult to anticipate. If the branch is predicted wrong, the whole pipeline must be flushed out and restart by fetching the correct branch.Many times when the next ( a few ) instructions depend on the result of previous instructions ( e.g., if conditions ), a prediction must be made. In general, floating number problems are easier to predict but integer comparisons are more difficult to anticipate. If the branch is predicted wrong, the whole pipeline must be flushed out and restart by fetching the correct branch.</p>
      </div>

      <div class="col-md-12 col-sm-12 col-xs-12">
        <p class="subtitle">Out-of-Order Execution</p>
        <p>This is the hardware-level parallelism. Instructions that use different CPU resources (e.g., memory vs register access ) can be executed simultaneously without causing troubles. This feature speeds up CPU farther on top of the pipelining design.This is the hardware-level parallelism. Instructions that use different CPU resources (e.g., memory vs register access ) can be executed simultaneously without causing troubles. This feature speeds up CPU farther on top of the pipelining design.This is the hardware-level parallelism. Instructions that use different CPU resources (e.g., memory vs register access ) can be executed simultaneously without causing troubles. This feature speeds up CPU farther on top of the pipelining design.This is the hardware-level parallelism. Instructions that use different CPU resources (e.g., memory vs register access ) can be executed simultaneously without causing troubles. This feature speeds up CPU farther on top of the pipelining design.This is the hardware-level parallelism. Instructions that use different CPU resources (e.g., memory vs register access ) can be executed simultaneously without causing troubles. This feature speeds up CPU farther on top of the pipelining design.This is the hardware-level parallelism. Instructions that use different CPU resources (e.g., memory vs register access ) can be executed simultaneously without causing troubles. This feature speeds up CPU farther on top of the pipelining design.This is the hardware-level parallelism. Instructions that use different CPU resources (e.g., memory vs register access ) can be executed simultaneously without causing troubles. This feature speeds up CPU farther on top of the pipelining design.This is the hardware-level parallelism. Instructions that use different CPU resources (e.g., memory vs register access ) can be executed simultaneously without causing troubles. This feature speeds up CPU farther on top of the pipelining design.</p>
      </div>

    </div>







  <!-- jQuery (Bootstrap JS plugins depend on it) -->
  <script src="js/jquery-1.11.3.min.js"></script>
  <script src="js/bootstrap.min.js"></script>
  <script src="js/script.js"></script>
</body>
</html>
